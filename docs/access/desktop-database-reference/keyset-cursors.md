---
title: Keysetcursor (Access PC-Datenbank-Referenz)
TOCTitle: Keyset Cursors
ms:assetid: 4b6e5f90-4413-4fb3-0a08-2cb89d3c61f7
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249236(v=office.15)
ms:contentKeyID: 48544690
ms.date: 09/18/2015
mtps_version: v=office.15
ms.openlocfilehash: 66e6b5ff69d22fa50d9765eb2087c373613bdb7d
ms.sourcegitcommit: c557bbcccf37a6011f89aae1ddd399dfe549d087
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/31/2018
ms.locfileid: "25886942"
---
# <a name="keyset-cursors"></a><span data-ttu-id="8b3a8-102">KEYSET-Cursor</span><span class="sxs-lookup"><span data-stu-id="8b3a8-102">Keyset Cursors</span></span>


<span data-ttu-id="8b3a8-103">**Betrifft**: Access 2013, Office 2013</span><span class="sxs-lookup"><span data-stu-id="8b3a8-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="8b3a8-p101">Der Keysetcursor stellt Funktionalität zwischen einem statischen und einem dynamischen Cursor bereit, um Änderungen zu erkennen. Wie ein statischer Cursor erkennt er nicht immer Änderungen an der Mitgliedschaft und der Reihenfolge des Resultsets. Wie ein dynamischer Cursor erkennt er keine Änderungen an den Werten von Zeilen im Resultset.</span><span class="sxs-lookup"><span data-stu-id="8b3a8-p101">The keyset cursor provides functionality between a static and a dynamic cursor in its ability to detect changes. Like a static cursor, it does not always detect changes to the membership and order of the result set. Like a dynamic cursor, it does detect changes to the values of rows in the result set.</span></span>

<span data-ttu-id="8b3a8-p102">Keysetgesteuerte Cursor werden durch eine Reihe eindeutiger Bezeichner (Schlüssel) gesteuert, die als Keyset bezeichnet werden. Die Schlüssel werden anhand von Spalten erstellt, die die Zeilen im Resultset eindeutig identifizieren. Das Keyset bezeichnet die Schlüsselwerte aller Zeilen, die von der Abfrageanweisung zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8b3a8-p102">Keyset-driven cursors are controlled by a set of unique identifiers (keys) known as the keyset. The keys are built from a set of columns that uniquely identify the rows in the result set. The keyset is the set of key values from all the rows returned by the query statement.</span></span>

<span data-ttu-id="8b3a8-p103">Mit keysetgesteuerten Cursorn wird für jede Zeile im Cursor ein Schlüssel erstellt und gespeichert und entweder auf der Clientarbeitsstation oder auf dem Server gespeichert. Wenn Sie auf eine Zeile zugreifen, werden mithilfe des gespeicherten Schlüssels die aktuellen Datenwerte aus der Datenquelle abgerufen. Bei einem keysetgesteuerten Cursor wird die Resultsetmitgliedschaft fixiert, wenn das Keyset vollständig aufgefüllt ist. Deshalb sind Hinzufügungen oder Aktualisierungen, die die Mitgliedschaft betreffen, erst nach dem erneuten Öffnen des Cursors im Resultset vorhanden.</span><span class="sxs-lookup"><span data-stu-id="8b3a8-p103">With keyset-driven cursors, a key is built and saved for each row in the cursor and stored either on the client workstation or on the server. When you access each row, the stored key is used to fetch the current data values from the data source. In a keyset-driven cursor, result set membership is frozen when the keyset is fully populated. Thereafter, additions or updates that affect membership are not a part of the result set until it is reopened.</span></span>

<span data-ttu-id="8b3a8-p104">Änderungen an Datenwerten (entweder durch den Keysetbesitzer oder durch andere Prozesse) werden angezeigt, wenn der Benutzer einen Bildlauf im Resultset ausführt. Einfügungen, die außerhalb des Cursors (durch andere Prozesse) ausgeführt werden, werden nur angezeigt, wenn der Cursor geschlossen und erneut geöffnet wird. Einfügungen, die innerhalb des Cursors ausgeführt werden, werden am Ende des Resultsets angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b3a8-p104">Changes to data values (made either by the keyset owner or other processes) are visible as the user scrolls through the result set. Inserts made outside the cursor (by other processes) are visible only if the cursor is closed and reopened. Inserts made from inside the cursor are visible at the end of the result set.</span></span>

<span data-ttu-id="8b3a8-p105">Wenn ein keysetgesteuerter Cursor versucht, eine gelöschte Zeile abzurufen, wird die Zeile als "Lücke" im Resultset angezeigt. Der Schlüssel für die Zeile ist im Keyset vorhanden, aber die Zeile ist nicht mehr im Resultset vorhanden. Falls die Schlüsselwerte in einer Zeile aktualisiert werden, wird die Zeile als gelöscht und dann eingefügt betrachtet, weshalb solche Zeilen ebenfalls als Lücke im Resultset dargestellt werden. Ein keysetgesteuerter Cursor kann immer Zeilen erkennen, die von anderen Prozessen gelöscht wurden, aber er kann optional die Schlüssel für Zeilen entfernen, die er selbst löscht. Keysetgesteuerte Cursor, die diesen Vorgang ausführen, können ihre eigenen Löschvorgänge erkennen, weil der Nachweis entfernt wurde.</span><span class="sxs-lookup"><span data-stu-id="8b3a8-p105">When a keyset-driven cursor attempts to retrieve a row that has been deleted, the row appears as a "hole" in the result set. The key for the row exists in the keyset, but the row no longer exists in the result set. If the key values in a row are updated, the row is considered to have been deleted and then inserted, so such rows also appear as holes in the result set. While a keyset-driven cursor can always detect rows deleted by other processes, it can optionally remove the keys for rows it deletes itself. Keyset-driven cursors that do this cannot detect their own deletes because the evidence has been removed.</span></span>

<span data-ttu-id="8b3a8-p106">Die Aktualisierung einer Schlüsselspalte verhält sich wie der Löschvorgang des alten Schlüssels, gefolgt vom Einfügen des neuen Schlüssels. Der neue Schlüsselwert wird nicht angezeigt, wenn die Aktualisierung nicht über den Cursor erfolgte. Falls die Aktualisierung über den Cursor erfolgte, wird der neue Schlüsselwert am Ende des Resultsets angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b3a8-p106">An update to a key column operates like a delete of the old key followed by an insert of the new key. The new key value is not visible if the update was not made through the cursor. If the update was made through the cursor, the new key value is visible at the end of the result set.</span></span>

<span data-ttu-id="8b3a8-p107">Bei keysetgesteuerten Cursorn gibt es eine Variante, die so genannten keysetgesteuerten Standardcursor. Bei einem keysetgesteuerten Standardcursor werden die Mitgliedschaft der Zeilen im Resultset und die Reihenfolge der Zeilen beim Öffnen des Cursors fixiert, aber Änderungen an Werten, die vom Cursorbesitzer ausgeführt werden, und Änderungen, für die ein Commit ausgeführt wurde und die von anderen Prozessen vorgenommen wurden, werden angezeigt. Falls eine Änderung eine Zeile von der Mitgliedschaft ausschließt oder die Reihenfolge einer Zeile ändert, wird die Zeile nur ausgeblendet oder verschoben, wenn der Cursor geschlossen und erneut geöffnet wird. Eingefügte Daten werden nicht angezeigt, aber Änderungen an vorhandenen Daten werden angezeigt, wenn die Zeilen abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="8b3a8-p107">There is a variation on keyset-driven cursors called keyset-driven standard cursors. In a keyset-driven standard cursor, the membership of rows in the result set and the order of the rows are fixed at cursor open time, but changes to values that are made by the cursor owner and committed changes made by other processes are visible. If a change disqualifies a row for membership or affects the order of a row, the row does not disappear or move unless the cursor is closed and reopened. Inserted data does not appear, but changes to existing data do appear as the rows are fetched.</span></span>

<span data-ttu-id="8b3a8-p108">Die richtige Verwendung des keysetgesteuerten Cursors ist schwierig, weil die Empfindlichkeit gegenüber Datenänderungen wie oben beschrieben von vielen verschiedenen Umständen abhängt. Wenn jedoch gleichzeitige Aktualisierungen für Ihre Anwendung keine Rolle spielen, wenn die Anwendung fehlerhafte Schlüssel programmgesteuert verarbeiten kann, und wenn die Anwendung auf bestimmte auf Schlüsseln basierende Zeilen direkt zugreifen muss, kann der keysetgesteuerte Cursor für Sie geeignet sein. Verwenden Sie **adOpenKeyset** für **CursorTypeEnum**, um anzugeben, dass Sie einen Keysetcursor in ADO verwenden möchten.</span><span class="sxs-lookup"><span data-stu-id="8b3a8-p108">The keyset-driven cursor is difficult to use correctly because the sensitivity to data changes depends on many differing circumstances, as described above. However, if your application is not concerned with concurrent updates, can programmatically handle bad keys, and must directly access certain keyed rows, the keyset-driven cursor might work for you. Use the **adOpenKeyset** **CursorTypeEnum** to indicate that you want to use a keyset cursor in ADO.</span></span>

