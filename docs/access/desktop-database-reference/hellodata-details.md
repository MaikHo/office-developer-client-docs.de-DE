---
title: Informationen zu HelloData (Access PC-Datenbank-Referenz)
TOCTitle: HelloData Details
ms:assetid: db51e15c-1b5b-c64a-2f84-34dd0e78c6cf
ms:mtpsurl: https://msdn.microsoft.com/library/JJ250105(v=office.15)
ms:contentKeyID: 48548103
ms.date: 09/18/2015
mtps_version: v=office.15
ms.openlocfilehash: c25197f0a8a45487f93f56543f73a2beeea062ff
ms.sourcegitcommit: a49b77f4c8cec69f90656a86f0872cf34c35968e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/17/2018
ms.locfileid: "25603155"
---
# <a name="hellodata-details"></a><span data-ttu-id="37b73-102">Informationen zu HelloData</span><span class="sxs-lookup"><span data-stu-id="37b73-102">HelloData Details</span></span>


<span data-ttu-id="37b73-103">**Betrifft**: Access 2013 | Office 2013</span><span class="sxs-lookup"><span data-stu-id="37b73-103">**Applies to**: Access 2013 | Office 2013</span></span>

<span data-ttu-id="37b73-p101">Mit der Anwendung HelloData werden die grundlegenden Vorgänge einer typischen ADO-Anwendung ausgeführt: Abrufen, Überprüfen, Bearbeiten und Aktualisieren von Daten. Klicken Sie beim Starten der Anwendung auf die erste Schaltfläche (Daten abrufen). Damit wird die GetData()-Subroutine ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="37b73-p101">The HelloData application steps through the basic operations of a typical ADO application: getting, examining, editing, and updating data. When you start the application, click the first button, **Get Data**. This will run the GetData() subroutine.</span></span>

## <a name="getdata"></a><span data-ttu-id="37b73-107">GetData</span><span class="sxs-lookup"><span data-stu-id="37b73-107">GetData</span></span>

<span data-ttu-id="37b73-108">GetData Fügt eine gültige Verbindungszeichenfolge in einer Variablen auf Modulebene *m\_sConnStr*.</span><span class="sxs-lookup"><span data-stu-id="37b73-108">GetData places a valid connection string into a module-level variable, *m\_sConnStr*.</span></span> <span data-ttu-id="37b73-109">Weitere Informationen zu Verbindungszeichenfolgen finden Sie unter [Erstellen der Verbindungszeichenfolge](creating-the-connection-string.md).</span><span class="sxs-lookup"><span data-stu-id="37b73-109">For more information about connection strings, see [Creating the Connection String](creating-the-connection-string.md).</span></span>

<span data-ttu-id="37b73-p103">Weisen Sie eine Fehlerbehandlungsroutine mithilfe der Visual Basic-Anweisung **OnError** zu. Weitere Informationen zur Fehlerbehandlung in ADO finden Sie in [Kapitel 6: Fehlerbehandlung](chapter-6-error-handling.md). Ein neues **Connection**-Objekt wird erstellt, und die **CursorLocation**-Eigenschaft wird auf **adUseClient** festgelegt, da mit dem HelloData-Beispiel eine *getrennte Datensatzgruppe* erstellt wird. Das bedeutet, dass die physikalische Verbindung nach dem Abrufen der Daten aus der Datenquelle unterbrochen wird. Sie können jedoch weiterhin mit den Daten arbeiten, da diese lokal im **Recordset**-Objekt zwischengespeichert sind.</span><span class="sxs-lookup"><span data-stu-id="37b73-p103">Assign an error handler using a Visual Basic **OnError** statement. For more information about error handling in ADO, see [Chapter 6: Error Handling](chapter-6-error-handling.md). A new **Connection** object is created, and the **CursorLocation** property is set to **adUseClient** because the HelloData example creates a *disconnected Recordset*. This means that once the data has been fetched from the data source, the physical connection with the data source is broken, but you can still work with the data that is cached locally in your **Recordset** object.</span></span>

<span data-ttu-id="37b73-114">Weisen Sie nach dem Öffnen der Verbindung einer Variablen (sSQL) eine SQL-Zeichenfolge zu.</span><span class="sxs-lookup"><span data-stu-id="37b73-114">After the connection has been opened, assign a SQL string to a variable (sSQL).</span></span> <span data-ttu-id="37b73-115">Instanziieren Sie ein neues **Recordset** -Objekt m\_oRecordset1.</span><span class="sxs-lookup"><span data-stu-id="37b73-115">Then instantiate a new **Recordset** object, m\_oRecordset1 .</span></span> <span data-ttu-id="37b73-116">Öffnen Sie in der nächsten Codezeile das **Recordset-Objekt** über das vorhandene **Connection**, übergeben.</span><span class="sxs-lookup"><span data-stu-id="37b73-116">In the next line of code, open the **Recordset** over the existing **Connection**, passing in .</span></span> <span data-ttu-id="37b73-117">Öffnen Sie in der nächsten Codezeile das **Recordset-Objekt** über das vorhandene **Connection**, sSQL als die Quelle des **Recordset-Objekts**übergeben.</span><span class="sxs-lookup"><span data-stu-id="37b73-117">In the next line of code, open the **Recordset** over the existing **Connection**, passing in sSQL as the source of the **Recordset**.</span></span> <span data-ttu-id="37b73-118">Unterstützen Sie ADO festlegen, dass die SQL-Zeichenfolge, die Sie als Quelle für das **Recordset-Objekt** übergeben haben Textdefinition eines Befehls, indem Sie **AdCmdText** im letzten Arguments an das **Recordset** **Open** -Methode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="37b73-118">You assist ADO in making the determination that the SQL string you have passed as the source for the **Recordset** is a textual definition of a command by passing **adCmdText** in the final argument to the **Recordset** **Open** method.</span></span> <span data-ttu-id="37b73-119">Diese Zeile auch die **LockType** und **CursorType** zugeordnete **Recordset-Objekt**.</span><span class="sxs-lookup"><span data-stu-id="37b73-119">This line also sets the **LockType** and **CursorType** associated with the **Recordset**.</span></span>

<span data-ttu-id="37b73-120"><<<<<<< HEAD die nächste Codezeile wird die **MarshalOptions** -Eigenschaft **AdMarshalModifiedOnly**gleich.</span><span class="sxs-lookup"><span data-stu-id="37b73-120"><<<<<<< HEAD The next line of code sets the **MarshalOptions** property equal to **adMarshalModifiedOnly**.</span></span> <span data-ttu-id="37b73-121">**MarshalOptions** gibt an, welche Datensätze auf die mittlere Ebene (oder den Webserver) gemarshallt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="37b73-121">**MarshalOptions** indicates which records should be marshaled to the middle tier (or Web server).</span></span> <span data-ttu-id="37b73-122">Weitere Informationen zum Marshalling finden Sie in der Dokumentation zu COM.</span><span class="sxs-lookup"><span data-stu-id="37b73-122">For more information about marshaling, see the COM documentation.</span></span> <span data-ttu-id="37b73-123">Wenn eine clientseitige Cursor **AdMarshalModifiedOnly** mit ([CursorLocation](cursorlocation-property-ado.md) = **AdUseClient**), nur die Datensätze, die auf dem Client geändert wurden in der mittleren Ebene zurückgeschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="37b73-123">When using **adMarshalModifiedOnly** with a client-side cursor ([CursorLocation](cursorlocation-property-ado.md) = **adUseClient**), only records that have been modified on the client are written back to the middle tier.</span></span> <span data-ttu-id="37b73-124">Wenn **MarshalOptions** auf **adMarshalModifiedOnly** festgelegt wird, wird möglicherweise die Leistung verbessert, da weniger Zeilen gemarshallt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="37b73-124">Setting **MarshalOptions** to **adMarshalModifiedOnly** can improve performance because fewer rows are marshaled.</span></span>
<span data-ttu-id="37b73-125">=== Die nächste Codezeile wird die **MarshalOptions** -Eigenschaft gleich **AdMarshalModifiedOnly**.</span><span class="sxs-lookup"><span data-stu-id="37b73-125">======= The next line of code sets the **MarshalOptions** property equal to **adMarshalModifiedOnly**.</span></span> <span data-ttu-id="37b73-126">**MarshalOptions** gibt an, welche Datensätze in der mittleren Ebene (oder Webserver) gemarshallt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="37b73-126">**MarshalOptions** indicates which records should be marshaled to the middle tier (or web server).</span></span> <span data-ttu-id="37b73-127">Weitere Informationen zum Marshalling finden Sie in der Dokumentation zu COM.</span><span class="sxs-lookup"><span data-stu-id="37b73-127">For more information about marshaling, see the COM documentation.</span></span> <span data-ttu-id="37b73-128">Wenn eine clientseitige Cursor **AdMarshalModifiedOnly** mit ([CursorLocation](cursorlocation-property-ado.md) = **AdUseClient**), nur die Datensätze, die auf dem Client geändert wurden in der mittleren Ebene zurückgeschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="37b73-128">When using **adMarshalModifiedOnly** with a client-side cursor ([CursorLocation](cursorlocation-property-ado.md) = **adUseClient**), only records that have been modified on the client are written back to the middle tier.</span></span> <span data-ttu-id="37b73-129">Wenn **MarshalOptions** auf **adMarshalModifiedOnly** festgelegt wird, wird möglicherweise die Leistung verbessert, da weniger Zeilen gemarshallt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="37b73-129">Setting **MarshalOptions** to **adMarshalModifiedOnly** can improve performance because fewer rows are marshaled.</span></span>
>>>>>>> <span data-ttu-id="37b73-130">master</span><span class="sxs-lookup"><span data-stu-id="37b73-130">master</span></span>

<span data-ttu-id="37b73-p106">Trennen Sie anschließend das **Recordset** -Objekt, indem Sie die zugehörige **ActiveConnection** -Eigenschaft auf **Nothing** setzen. Weitere Informationen finden Sie unter [Trennen und Wiederherstellen der Verbindung für das Recordset-Objekt](disconnecting-and-reconnecting-the-recordset.md) in "Kapitel 5: Aktualisieren und Speichern von Daten".</span><span class="sxs-lookup"><span data-stu-id="37b73-p106">Next, disconnect the **Recordset** by setting its **ActiveConnection** property equal to **Nothing**. For more information, see [Disconnecting and Reconnecting the Recordset](disconnecting-and-reconnecting-the-recordset.md) in Chapter 5: Updating and Persisting Data.</span></span>

<span data-ttu-id="37b73-133">Schließen Sie die Verbindung mit der Datenquelle, und löschen Sie das vorhandene **Connection** -Objekt. Damit geben Sie die von diesem Objekt belegten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="37b73-133">Close the connection to the data source and destroy the existing **Connection** object, thereby releasing the resources it consumed.</span></span>

<span data-ttu-id="37b73-134">In einem letzten Schritt wird das **Recordset** -Objekt als **DataSource** für Microsoft DataBound-Rastersteuerelement auf dem Formular festgelegt, sodass die Daten aus dem **Recordset** -Objekt problemlos auf dem Formular angezeigt werden können.</span><span class="sxs-lookup"><span data-stu-id="37b73-134">The final step is to set the **Recordset** as the **DataSource** for the Microsoft DataBound Grid Control on the form so that you can easily display the data from the **Recordset** on the form.</span></span>

<span data-ttu-id="37b73-p107">Klicken Sie auf die zweite Schaltfläche (Daten prüfen). Die ExamineData-Subroutine wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="37b73-p107">Click the second button, **Examine Data**. This runs the ExamineData subroutine.</span></span>

## <a name="examinedata"></a><span data-ttu-id="37b73-137">ExamineData</span><span class="sxs-lookup"><span data-stu-id="37b73-137">ExamineData</span></span>

<span data-ttu-id="37b73-p108">ExamineData verwendet verschiedene Methoden und Eigenschaften des Recordset-Objekts zum Anzeigen von Informationen zu den Daten im Recordset-Objekt. Die Subroutine meldet die Anzahl von Datensätzen mithilfe der RecordCount-Eigenschaft. Sie führt das Recordset-Objekt in Schleifen aus und druckt den Wert der AbsolutePosition-Eigenschaft in das Anzeigetextfeld auf dem Formular. Zudem wird beim Ausführen der Schleife der Wert der Bookmark-Eigenschaft für den dritten Datensatz für die spätere Verwendung in eine Variable vom Typ Variant (vBookmark) eingefügt.</span><span class="sxs-lookup"><span data-stu-id="37b73-p108">ExamineData uses various methods and properties of the **Recordset** object to display information about the data in the **Recordset**. It reports the number of records by using the **RecordCount** property. It loops through the **Recordset** and prints the value of the **AbsolutePosition** property in the display text box on the form. Also while in the loop, the value of the **Bookmark** property for the third record is placed into a variant variable, *vBookmark*, for later use.</span></span>

<span data-ttu-id="37b73-p109">Die Routine kehrt mithilfe der zuvor gespeicherten Textmarkenvariablen direkt zum dritten Datensatz zurück. Die Routine ruft die WalkFields-Subroutine auf, die die Fields-Auflistung des Recordset-Objekts in Schleifen ausführt und Informationen zu jedem Field-Eintrag in der Auflistung anzeigt.</span><span class="sxs-lookup"><span data-stu-id="37b73-p109">The routine navigates directly back to the third record using the bookmark variable that it stored earlier. The routine calls the WalkFields subroutine, which loops through the **Fields** collection of the **Recordset** and displays details about each **Field** in the collection.</span></span>

<span data-ttu-id="37b73-p110">Abschließend verwendet die ExamineData-Subroutine die Filter-Eigenschaft des Recordset-Objekts, um nur nach den Datensätzen zu suchen, deren CategoryId-Wert gleich 2 ist. Das Ergebnis dieses Filters wird auf dem Anzeigeraster des Formulars sofort angezeigt.</span><span class="sxs-lookup"><span data-stu-id="37b73-p110">Finally, ExamineData uses the **Filter** property of the **Recordset** to screen for only those records with a CategoryId equal to 2. The result of applying this filter is immediately visible in the display grid on the form.</span></span>

<span data-ttu-id="37b73-146">Weitere Informationen zu der in der ExamineData-Subroutine dargestellten Funktionalität finden Sie in Kapitel 3: Untersuchen von Daten.</span><span class="sxs-lookup"><span data-stu-id="37b73-146">For more information about the functionality shown in the ExamineData subroutine, see [Chapter 3: Examining Data](chapter-3-examining-data.md).</span></span>

<span data-ttu-id="37b73-p111">Klicken Sie nun auf die dritte Schaltfläche (Daten bearbeiten). Damit wird die EditData-Subroutine ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="37b73-p111">Next, click the third button, **Edit Data**. This will run the EditData subroutine.</span></span>

## <a name="editdata"></a><span data-ttu-id="37b73-149">EditData</span><span class="sxs-lookup"><span data-stu-id="37b73-149">EditData</span></span>

<span data-ttu-id="37b73-p112">Wenn der Code mit der Ausführung der EditData-Subroutine beginnt, wird das Recordset-Objekt noch nach Einträgen gefiltert, deren CategoryId-Wert gleich 2 ist. Daher werden nur die Elemente angezeigt, die diesem Filterkriterium entsprechen. Die Subroutine führt zunächst das Recordset-Objekt in Schleifen aus und erhöht den Preis der im Recordset-Objekt angezeigten Elemente um 10 %. Der Wert des Price-Felds wird geändert, indem die Value-Eigenschaft für das Feld auf einen neuen gültigen Betrag gesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="37b73-p112">When the code enters the EditData subroutine, the **Recordset** is still filtered on CategoryId equal to 2, so only those items that meet the filter criteria are visible. It first loops through the **Recordset** and increases the price of each visible item in the **Recordset** by 10 percent. The value of the **Price** field is changed by setting the **Value** property for that field equal to a new, valid amount.</span></span>

<span data-ttu-id="37b73-p113">Beachten Sie, dass das Recordset-Objekt von der Datenquelle getrennt ist. Die in der EditData-Subroutine vorgenommenen Änderungen werden nur für die lokal zwischengespeicherte Kopie der Daten übernommen. Weitere Informationen finden Sie in Kapitel 4: Bearbeiten von Daten.</span><span class="sxs-lookup"><span data-stu-id="37b73-p113">Remember that the **Recordset** is disconnected from the data source. The changes made in EditData are made only to the locally cached copy of the data. For more information, see [Chapter 4: Editing Data](chapter-4-editing-data.md).</span></span>

<span data-ttu-id="37b73-p114">Die Änderungen werden in der Datenquelle erst übernommen, wenn Sie auf die vierte Schaltfläche (Daten aktualisieren) klicken. Die UpdateData-Subroutine wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="37b73-p114">The changes will not be made on the data source until you click the fourth button, **Update Data**. This will run the UpdateData subroutine.</span></span>

## <a name="updatedata"></a><span data-ttu-id="37b73-158">UpdateData</span><span class="sxs-lookup"><span data-stu-id="37b73-158">UpdateData</span></span>

<span data-ttu-id="37b73-159">UpdateData entfernt zuerst den Filter, der an das **Recordset**angewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="37b73-159">UpdateData first removes the filter that has been applied to the **Recordset**.</span></span> <span data-ttu-id="37b73-160">Der Code entfernt und als **DataSource** für das Microsoft Bound DataGrid auf dem Formular zurückgesetzt, sodass das ungefilterte **Recordset-Objekt** im Raster angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="37b73-160">The code removes and resets as the **DataSource** for the Microsoft Bound DataGrid on the form so that the unfiltered **Recordset** appears in the grid.</span></span>

<span data-ttu-id="37b73-161">Der Code überprüft als Nächstes, ob Sie sich im **Recordset** -Objekt mithilfe der **Supports** -Methode mit dem **adMovePrevious** -Argument zurück bewegen können.</span><span class="sxs-lookup"><span data-stu-id="37b73-161">The code then checks to see whether you can move backward in the **Recordset** by using the **Supports** method with the **adMovePrevious** argument.</span></span>

<span data-ttu-id="37b73-p116">Die Routine kehrt mit der **MoveFirst** -Methode zum ersten Datensatz zurück und zeigt den ursprünglichen und aktuellen Wert des Felds an. Hierzu werden die Eigenschaften **OriginalValue** und **Value** des **Field** -Objekts verwendet. Diese Eigenschaften werden zusammen mit der **UnderlyingValue** -Eigenschaft (hier nicht verwendet) in [Kapitel 5: Aktualisieren und Speichern von Daten](chapter-5-updating-and-persisting-data.md) beschrieben.</span><span class="sxs-lookup"><span data-stu-id="37b73-p116">The routine moves to the first record using the **MoveFirst** method and displays the field's original and current values, using the **OriginalValue** and **Value** properties of the **Field** object. These properties, along with the **UnderlyingValue** property (not used here), are discussed in [Chapter 5: Updating and Persisting Data](chapter-5-updating-and-persisting-data.md).</span></span>

<span data-ttu-id="37b73-p117">Im nächsten Schritt wird ein neues **Connection** -Objekt erstellt und verwendet, um mit der Datenquelle erneut eine Verbindung herzustellen. Sie verbinden das **Recordset** -Objekt erneut mit der Datenquelle, indem Sie das neue **Connection** -Objekt als **ActiveConnection** für das **Recordset** -Objekt festlegen. Um die Aktualisierungen an den Server zu senden, ruft der Code **UpdateBatch** auf dem **Recordset** -Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="37b73-p117">Next, a new **Connection** object is created and used to reestablish a connection to the data source. You reconnect the **Recordset** to the data source by setting the new **Connection** as the **ActiveConnection** for the **Recordset**. To send the updates to the server, the code calls **UpdateBatch** on the **Recordset**.</span></span>

<span data-ttu-id="37b73-167">Wenn die Batchaktualisierung erfolgreich ist, handelt es sich bei eine Variablen auf Modulebene Kennzeichnung, auf True festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="37b73-167">If the batch update succeeds, a module-level flag variable, , is set to True.</span></span> <span data-ttu-id="37b73-168">Dadurch werden Sie später auf, um alle Änderungen an der Datenbank bereinigen daran erinnern.</span><span class="sxs-lookup"><span data-stu-id="37b73-168">This will remind you later to clean up all changes made to the database.</span></span>

<span data-ttu-id="37b73-p119">In einem letzten Schritt kehrt der Code zum ersten Datensatz im **Recordset** -Objekt zurück und zeigt den ursprünglichen und aktuellen Wert an. Diese beiden Werte sind nach dem Aufruf von **UpdateBatch** identisch.</span><span class="sxs-lookup"><span data-stu-id="37b73-p119">Finally, the code moves back to the first record in the **Recordset** and displays the original and current values. The values are the same after the call to **UpdateBatch**.</span></span>

<span data-ttu-id="37b73-171">Ausführlichere Informationen zum Aktualisieren von Daten sowie Anweisungen zur Vorgehensweise, wenn Daten auf dem Server geändert werden, während das **Recordset** -Objekt getrennt ist, finden Sie in [Kapitel 5: Aktualisieren und Speichern von Daten](chapter-5-updating-and-persisting-data.md).</span><span class="sxs-lookup"><span data-stu-id="37b73-171">For more detailed information about updating data, including what to do when data on the server changes while your **Recordset** is disconnected, see [Chapter 5: Updating and Persisting Data](chapter-5-updating-and-persisting-data.md).</span></span>

## <a name="formunload"></a><span data-ttu-id="37b73-172">Formular\_entladen</span><span class="sxs-lookup"><span data-stu-id="37b73-172">Form\_Unload</span></span>

<span data-ttu-id="37b73-173">Das Formular\_Unload-Unterroutine ist aus verschiedenen Gründen zu wichtig.</span><span class="sxs-lookup"><span data-stu-id="37b73-173">The Form\_Unload subroutine is important for several reasons.</span></span> <span data-ttu-id="37b73-174">Erste, da dies ein Beispiel für Formular ist\_Unload bereinigt die Änderungen an der Datenbank vor dem Beenden der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="37b73-174">First, because this is a sample application, Form\_Unload cleans up the changes made to the database before the application exits.</span></span> <span data-ttu-id="37b73-175">Zweitens zeigt den Code, wie ein Befehl direkt über ein geöffnetes **Connection** -Objekt mithilfe der **Execute** -Methode ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="37b73-175">Second, the code shows how a command can be executed directly from an open **Connection** object using the **Execute** method.</span></span> <span data-ttu-id="37b73-176">Abschließend wird ein Beispiel für die Ausführung einer Abfrage nicht Zeile zurückgibt (eine Aktualisierungsabfrage) für die Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="37b73-176">Finally, it shows an example of executing a non-row–returning query (an UPDATE query) against the data source.</span></span>

