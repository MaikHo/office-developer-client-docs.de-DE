---
title: Zusammenarbeit von Ereignishandlern
TOCTitle: How Event Handlers Work Together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
ms.openlocfilehash: 8d156de0a794798be6f7e68925d934c07a28cd60
ms.sourcegitcommit: 19aca09c5812cfb98b68b5d4604dcaa814479df7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/09/2018
ms.locfileid: "25475552"
---
# <a name="how-event-handlers-work-together"></a><span data-ttu-id="a59b4-102">Zusammenarbeit von Ereignishandlern</span><span class="sxs-lookup"><span data-stu-id="a59b4-102">How Event Handlers Work Together</span></span>


<span data-ttu-id="a59b4-103">**Betrifft**: Access 2013 | Office 2013</span><span class="sxs-lookup"><span data-stu-id="a59b4-103">**Applies to**: Access 2013 | Office 2013</span></span>



<span data-ttu-id="a59b4-p101">Wenn Sie nicht in Visual Basic programmieren, müssen, unabhängig davon, ob Sie tatsächlich alle Ereignisse verarbeiten, alle Ereignishandler für die Ereignisse **Connection** und **Recordset** implementiert werden. Der Implementierungsaufwand hängt von der Programmiersprache ab. Weitere Informationen finden Sie unter [ADO-Ereignisinstanziierung nach Sprache](https://msdn.microsoft.com/library/jj250244\(v=office.15\)).</span><span class="sxs-lookup"><span data-stu-id="a59b4-p101">Unless you are programming in Visual Basic, all event handlers for **Connection** and **Recordset** events must be implemented, regardless of whether you actually process all of the events. The amount of implementation work you have to do depends on your programming language. For more information, see [ADO Event Instantiation by Language](https://msdn.microsoft.com/library/jj250244\(v=office.15\)).</span></span>

## <a name="paired-event-handlers"></a><span data-ttu-id="a59b4-107">Kombinierte Ereignishandler</span><span class="sxs-lookup"><span data-stu-id="a59b4-107">Paired Event Handlers</span></span>

<span data-ttu-id="a59b4-p102">Jedem Will-Ereignishandler ist ein Complete-Ereignishandler zugeordnet. Wenn z. B. durch die Anwendung der Wert eines Felds geändert wird, wird der WillChangeField-Ereignishandler aufgerufen. Wenn die Änderung akzeptabel ist, bleibt der adStatus-Parameter unverändert, und die Operation wird ausgeführt. Wenn die Operation abgeschlossen ist, wird die Anwendung durch ein FieldChangeComplete-Ereignis benachrichtigt, dass die Operation beendet ist. Wenn sie erfolgreich abgeschlossen wurde, enthält adStatus den Wert adStatusOK; andernfalls enthält adStatus den Wert adStatusErrorsOccurred, und Sie müssen das Error-Objekt überprüfen, um die Ursache des Fehlers zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p102">Each Will event handler has an associated Complete event handler. For example, when your application changes the value of a field, the **WillChangeField** event handler is called. If the change is acceptable, your application leaves the **adStatus** parameter unchanged and the operation is performed. When the operation completes, a **FieldChangeComplete** event notifies your application that the operation has finished. If it completed successfully, **adStatus** contains **adStatusOK**; otherwise, **adStatus** contains **adStatusErrorsOccurred** and you must check the **Error** object to determine the cause of the error.</span></span>

<span data-ttu-id="a59b4-p103">Wenn **WillChangeField** aufgerufen wird, ermitteln Sie möglicherweise, dass die Änderung nicht vorgenommen werden soll. Legen Sie in diesen Fall **adStatus** auf **adStatusCancel** fest. Die Operation wird abgebrochen, und das **FieldChangeComplete** -Ereignis empfängt für **adStatus** den Wert **adStatusErrorsOccurred**. Das **Error** -Objekt enthält **adErrOperationCancelled**, sodass dem **FieldChangeComplete** -Handler mitgeteilt wird, dass die Operation abgebrochen wurde. Sie müssen jedoch den Wert des **adStatus** -Parameters vor dem Ändern überprüfen, da das Festlegen von **adStatus** auf **adStatusCancel** keine Auswirkung hat, wenn der Parameter bei Beginn des Verfahrens auf **adStatusCantDeny** festgelegt war.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p103">When **WillChangeField** is called, you might determine that the change should not be made. In that case, set **adStatus** to **adStatusCancel**. The operation is canceled and the **FieldChangeComplete** event receives an **adStatus** value of **adStatusErrorsOccurred**. The **Error** object contains **adErrOperationCancelled** so that your **FieldChangeComplete** handler knows that the operation was canceled. However, you need to check the value of the **adStatus** parameter before changing it, because setting **adStatus** to **adStatusCancel** has no effect if the parameter was set to **adStatusCantDeny** on entry to the procedure.</span></span>

<span data-ttu-id="a59b4-p104">Manchmal wird von einer Operation mehr als ein Ereignis ausgelöst. Beispielsweise verfügt das Recordset-Objekt über kombinierte Ereignisse für Field- und Record-Änderungen. Wenn der Wert eines Field-Objekts von der Anwendung geändert wird, wird der WillChangeField-Ereignishandler aufgerufen. Wenn durch ihn bestimmt wird, dass die Operation fortgesetzt werden kann, wird außerdem der WillChangeRecord-Ereignishandler ausgelöst. Wenn auch durch diesen Handler das Fortsetzen des Ereignisses zugelassen wird, wird die Änderung vorgenommen, und die Ereignishandler FieldChangeComplete und RecordChangeComplete werden aufgerufen. Da die Reihenfolge, in der die Will-Ereignishandler für eine bestimmte Operation aufgerufen werden, nicht definiert ist, sollten Sie das Schreiben von Code vermeiden, der davon abhängt, dass Handler in einer bestimmten Reihenfolge aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p104">Sometimes an operation can raise more than one event. For example, the **Recordset** object has paired events for **Field** changes and **Record** changes. When your application changes the value of a **Field**, the **WillChangeField** event handler is called. If it determines that the operation can continue, the **WillChangeRecord** event handler is also raised. If this handler also allows the event to continue, the change is made and the **FieldChangeComplete** and **RecordChangeComplete** event handlers are called. The order in which the Will event handlers for a particular operation are called is not defined, so you should avoid writing code that depends on calling handlers in a particular sequence.</span></span>

<span data-ttu-id="a59b4-p105">In Fällen, in denen mehrere Will-Ereignisse ausgelöst werden, wird die Operation möglicherweise durch eines der Ereignisse abgebrochen. Wenn die Anwendung z. B. den Wert eines Field-Objekts ändert, werden normalerweise die Ereignishandler WillChangeField und WillChangeRecord aufgerufen. Wenn die Operation jedoch im ersten Ereignishandler abgebrochen wird, wird sofort der diesem zugeordnete Complete-Handler mit adStatusOperationCancelled aufgerufen. Der zweite Handler wird nie aufgerufen. Wenn jedoch durch den ersten Ereignishandler die Fortsetzung des Ereignisses zugelassen wird, wird der andere Ereignishandler aufgerufen. Wenn dann von diesem die Operation abgebrochen wird, werden wie in den vorherigen Beispielen beide Complete-Ereignisse aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p105">In instances when multiple Will events are raised, one of the events might cancel the pending operation. For example, when your application changes the value of a **Field**, both **WillChangeField** and **WillChangeRecord** event handlers would normally be called. However, if the operation is canceled in the first event handler, its associated Complete handler is immediately called with **adStatusOperationCancelled**. The second handler is never called. If, however, the first event handler allows the event to proceed, the other event handler will be called. If it then cancels the operation, both Complete events will be called as in the earlier examples.</span></span>

## <a name="unpaired-event-handlers"></a><span data-ttu-id="a59b4-130">Nicht kombinierte Ereignishandler</span><span class="sxs-lookup"><span data-stu-id="a59b4-130">Unpaired Event Handlers</span></span>

<span data-ttu-id="a59b4-p106">Solange der dem Ergebnis übergebene Status nicht adStatusCantDeny entspricht, können Sie Ereignisbenachrichtigungen für ein Ereignis deaktivieren, indem Sie adStatusUnwantedEvent im Status-Parameter zurückgeben. Wenn z. B. der Complete-Ereignishandler zum ersten Mal aufgerufen wird, können Sie adStatusUnwantedEvent zurückgeben. Anschließend empfangen Sie nur Will-Ereignisse. Manche Ereignisse können jedoch aus mehreren Gründen ausgelöst werden. In diesem Fall hat das Ereignis einen Reason-Parameter. Wenn Sie adStatusUnwantedEvent zurückgeben, empfangen Sie für dieses Ereignis nur dann keine Benachrichtigungen mehr, wenn sie aus dem jeweiligen Grund auftreten. Mit anderen Worten: Sie empfangen potenziell Benachrichtigungen für jeden möglichen Grund, durch den das Ereignis ausgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p106">As long as the status passed to the event is not **adStatusCantDeny**, you can turn off event notifications for any event by returning **adStatusUnwantedEvent** in the *Status* parameter. For example, when your Complete event handler is called the first time, you can return **adStatusUnwantedEvent**. You will subsequently receive only Will events. However, some events can be triggered for more than one reason. In that case, the event will have a *Reason* parameter. When you return **adStatusUnwantedEvent**, you will stop receiving notifications for that event only when they occur for that particular reason. In other words, you will potentially receive notification for each possible reason that the event could be triggered.</span></span>

<span data-ttu-id="a59b4-p107">Einzelne Will-Ereignishandler können hilfreich sein, wenn Sie die Parameter überprüfen möchten, die in einer Operation verwendet werden sollen. Sie können diese Operationsparameter ändern oder die Operation abbrechen.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p107">Single Will event handlers can be useful when you want to examine the parameters that will be used in an operation. You can modify those operation parameters or cancel the operation.</span></span>

<span data-ttu-id="a59b4-p108">Lassen Sie alternativ die Benachrichtigung für Complete-Ereignisse aktiviert. Wenn der erste Will-Ereignishandler aufgerufen wird, geben Sie adStatusUnwantedEvent zurück. Anschließend empfangen Sie nur Complete-Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p108">Alternatively, leave Complete event notification enabled. When your first Will event handler is called, return **adStatusUnwantedEvent**. You will subsequently receive only Complete events.</span></span>

<span data-ttu-id="a59b4-p109">Einzelne Complete-Ereignishandler können hilfreich sein beim Verwalten asynchroner Operationen. Jede asynchrone Operation hat ein entsprechendes Complete-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p109">Single Complete event handlers can be useful for managing asynchronous operations. Each asynchronous operation has an appropriate Complete event.</span></span>

<span data-ttu-id="a59b4-145">Beispielsweise kann das Auffüllen eines großen [Recordset](recordset-object-ado.md)-Objekts viel Zeit beanspruchen.</span><span class="sxs-lookup"><span data-stu-id="a59b4-145">For example, it can take a long time to populate a large [Recordset](recordset-object-ado.md) object.</span></span> <span data-ttu-id="a59b4-146">Wenn die Anwendung entsprechend geschrieben ist, können Sie einen Vorgang starten und andere Verarbeitung fort.</span><span class="sxs-lookup"><span data-stu-id="a59b4-146">If your application is appropriately written, you can start a operation and continue with other processing.</span></span> <span data-ttu-id="a59b4-147">Sie werden schließlich benachrichtigt, wenn das **Recordset** mit einem **ExecuteComplete** -Ereignis aufgefüllt ist.</span><span class="sxs-lookup"><span data-stu-id="a59b4-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span></span>

## <a name="single-event-handlers-and-multiple-objects"></a><span data-ttu-id="a59b4-148">Einzelne Ereignishandler und mehrere Objekte</span><span class="sxs-lookup"><span data-stu-id="a59b4-148">Single Event Handlers and Multiple Objects</span></span>

<span data-ttu-id="a59b4-p111">Die Flexibilität einer Programmiersprache wie Microsoft Visual C++ ermöglicht die Verarbeitung von Ereignissen mehrerer Objekte durch einen Ereignishandler. Beispielsweise können Sie einen **Disconnect** -Ereignishandler Ereignisse von verschiedenen **Connection** -Objekten verarbeiten lassen. Wenn eine der Verbindungen beendet wird, wird der **Disconnect** -Ereignishandler aufgerufen. Sie können erkennen, durch welche Verbindung das Ereignis verursacht wurde, da der Objektparameter des Ereignishandlers auf das entsprechende **Connection** -Objekt festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="a59b4-p111">The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects. For example, you could have one **Disconnect** event handler process events from several **Connection** objects. If one of the connections ended, the **Disconnect** event handler would be called. You could tell which connection caused the event because the event-handler object parameter would be set to the corresponding **Connection** object.</span></span>


> [!NOTE]
> <P><span data-ttu-id="a59b4-153">[!HINWEIS] Diese Technik kann in Visual Basic nicht verwendet werden, da die Sprache nur ein Objekt zu einem Ereignishandler korrelieren kann.</span><span class="sxs-lookup"><span data-stu-id="a59b4-153">This technique cannot be used in Visual Basic because that language can correlate only one object to an event handler.</span></span></P>


