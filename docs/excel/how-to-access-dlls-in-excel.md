---
title: Zugriff auf DLLs in Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- accessing dlls [excel 2007],DLLs [Excel 2007], accessing in Excel
localization_priority: Normal
ms.assetid: e2bfd6ea-efa3-45c1-a5b8-2ccb8650c6ab
description: 'Gilt für: Excel 2013 | Office 2013 | Visual Studio'
ms.openlocfilehash: bfb562b6bbe824124c6b5a691745d076720ee004
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/11/2018
ms.locfileid: "19790507"
---
# <a name="access-dlls-in-excel"></a><span data-ttu-id="677ec-104">Zugriff auf DLLs in Excel</span><span class="sxs-lookup"><span data-stu-id="677ec-104">Access DLLs in Excel</span></span>

<span data-ttu-id="677ec-105">**Gilt für**: Excel 2013 | Office 2013 | Visual Studio</span><span class="sxs-lookup"><span data-stu-id="677ec-105">**Applies to**: Excel 2013 | Office 2013 | Visual Studio</span></span> 
  
<span data-ttu-id="677ec-106">Es gibt in Microsoft Excel mehrere Möglichkeiten, auf eine DLL-Funktion oder einen DLL-Befehl zuzugreifen:</span><span class="sxs-lookup"><span data-stu-id="677ec-106">You can access a DLL function or command in Microsoft Excel in several ways:</span></span>
  
- <span data-ttu-id="677ec-107">Über ein Microsoft VBA-Codemodul (Visual Basic for Applications), in dem die Funktion oder der Befehl mithilfe einer **Declare**-Anweisung verfügbar gemacht wurde</span><span class="sxs-lookup"><span data-stu-id="677ec-107">Through a Microsoft Visual Basic for Applications (VBA) code module in which the function or command has been made available using a **Declare** statement.</span></span> 
    
- <span data-ttu-id="677ec-108">Über eine XLM-Makrovorlage mithilfe der Funktion **CALL** oder **REGISTER**</span><span class="sxs-lookup"><span data-stu-id="677ec-108">Through an XLM macro sheet by using the **CALL** or **REGISTER** functions.</span></span> 
    
- <span data-ttu-id="677ec-109">Direkt aus dem Arbeitsblatt oder von einem angepassten Element in der Benutzeroberfläche</span><span class="sxs-lookup"><span data-stu-id="677ec-109">Directly from the worksheet or from a customized item in the user interface (UI).</span></span>
    
<span data-ttu-id="677ec-p101">XLM-Funktionen werden in dieser Dokumentation nicht behandelt. Verwenden Sie nach Möglichkeit eine der beiden anderen Methoden.</span><span class="sxs-lookup"><span data-stu-id="677ec-p101">This documentation does not cover XLM functions. It is recommended that you use either of the other two approaches.</span></span>
  
<span data-ttu-id="677ec-p102">Für den direkten Zugriff aus dem Arbeitsblatt oder von einem angepassten Element der Benutzeroberfläche muss die Funktion oder der Befehl zunächst bei Excel registriert werden. Informationen über das Registrieren von Befehlen und Funktionen finden Sie unter [Zugriff auf XLL-Code in Excel (engl.)](accessing-xll-code-in-excel.md).</span><span class="sxs-lookup"><span data-stu-id="677ec-p102">To be accessed directly from the worksheet or from a customized item in the UI, the function or command must first be registered with Excel. For information about registering commands and functions, see [Accessing XLL Code in Excel](accessing-xll-code-in-excel.md).</span></span>
  
## <a name="calling-dll-functions-and-commands-from-vba"></a><span data-ttu-id="677ec-114">Aufrufen von DLL-Funktionen und Befehle von VBA</span><span class="sxs-lookup"><span data-stu-id="677ec-114">Calling DLL functions and commands from VBA</span></span>

<span data-ttu-id="677ec-p103">In VBA können Sie mit der **Declare**-Anweisung auf DLL-Funktionen und -Befehle zugreifen. Diese Anweisung verfügt über eine Syntax für Befehle und eine für Funktionen.</span><span class="sxs-lookup"><span data-stu-id="677ec-p103">You can access DLL functions and commands in VBA by using the **Declare** statement. This statement has one syntax for commands and one for functions.</span></span> 
  
- <span data-ttu-id="677ec-117">**Syntax 1 � Befehle**</span><span class="sxs-lookup"><span data-stu-id="677ec-117">**Syntax 1 - commands**</span></span>
    
  ```vb
  [Public | Private] Declare Sub name Lib "libname" [Alias "aliasname"] [([arglist])]
  ```

- <span data-ttu-id="677ec-118">**Syntax 2 � Funktionen**</span><span class="sxs-lookup"><span data-stu-id="677ec-118">**Syntax 2 - functions**</span></span>
    
  ```vb
  [Public | Private] Declare Function name Lib "libname" [Alias "aliasname"] [([arglist])] [As type]
  ```

<span data-ttu-id="677ec-p104">Die optionalen Schlüsselw�rter **Public** und **Private** geben den Geltungsbereich der importierten Funktion an: das gesamte Visual Basic-Projekt bzw. nur das Visual Basic-Modul. Der Name ist der Name, den Sie im VBA-Code verwenden möchten. Wenn sich dieser vom Namen in der DLL unterscheidet, müssen Sie den Aliasspezifizierer "aliasname" verwenden und sollten den Namen der Funktion so angeben, wie er von der DLL exportiert wird. Wenn Sie durch Verweis auf eine DLL-Ordnungszahl auf eine DLL-Funktion zugreifen möchten, müssen Sie einen Aliasnamen angeben, der aus der Ordnungszahl mit dem Präfix **#** besteht.</span><span class="sxs-lookup"><span data-stu-id="677ec-p104">The optional **Public** and **Private** keywords specify the scope of the imported function: the entire Visual Basic project or just the Visual Basic module, respectively. The name is the name that you want to use in the VBA code. If this differs from the name in the DLL, you must use the Alias "aliasname" specifier, and you should give the name of the function as exported by the DLL. If you want to access a DLL function by reference to a DLL ordinal number, you must provide an alias name, which is the ordinal prefixed by **#**.</span></span>
  
<span data-ttu-id="677ec-p105">Befehle müssen **void** zurückgeben. Funktionen müssen Typen zurückgeben, die VBA **ByVal** erkennen kann. Dies bedeutet, dass einige Typen einfacher zurückgegeben werden, wenn Argumente direkt geändert werden: Zeichenfolgen, Arrays, benutzerdefinierte Typen und Objekte.</span><span class="sxs-lookup"><span data-stu-id="677ec-p105">Commands should return **void**. Functions should return types that VBA can recognize **ByVal**. This means that some types are more easily returned by modifying arguments in place: strings, arrays, user-defined types, and objects.</span></span>
  
> [!NOTE]
> <span data-ttu-id="677ec-p106">VBA kann nicht überpr�fen, ob die im Visual Basic-Modul angegebene Argumentliste und Rückgabe identisch mit den in der DLL-Datei codierten Werten sind. Sie sollten dies selbst sehr sorgfältig pr�fen, da ein Fehler zum Absturz von Excel führen kann.</span><span class="sxs-lookup"><span data-stu-id="677ec-p106">VBA cannot check that the argument list and return stated in the Visual Basic module are the same as coded in the DLL. You should check this yourself very carefully, because a mistake could cause Excel to crash.</span></span> 
  
<span data-ttu-id="677ec-p107">Wenn die Argumente der Funktion oder des Befehls nicht durch Verweis oder Zeiger Übergeben werden, muss ihnen das **ByVal**-Schlüsselwort in der **arglist**-Deklaration vorangestellt werden. Wenn eine C/C++-Funktion Zeigerargumente oder eine C++-Funktion Verweisargumente verwendet, müssen diese Funktionen **ByRef** Übergeben werden. Das **ByRef**-Schlüsselwort kann in Argumentlisten ausgelassen werden, da es der VBA-Standardwert ist.</span><span class="sxs-lookup"><span data-stu-id="677ec-p107">When the function or command's arguments are not passed by reference or pointer, they must be preceded by the **ByVal** keyword in the **arglist** declaration. When a C/C++ function takes pointer arguments, or a C++ function takes reference arguments, they should be passed **ByRef**. The keyword **ByRef** can be omitted from argument lists because it is the default in VBA.</span></span> 
  
### <a name="argument-types-in-cc-and-vba"></a><span data-ttu-id="677ec-131">Elementtypen in C/C++- und VBA</span><span class="sxs-lookup"><span data-stu-id="677ec-131">Argument types in C/C++ and VBA</span></span>

<span data-ttu-id="677ec-132">Beachten Sie beim Vergleichen der Deklarationen von Argumenttypen in C/C++ und VBA die folgenden Punkte.</span><span class="sxs-lookup"><span data-stu-id="677ec-132">You should note the following when you compare the declarations of argument types in C/C++ and VBA.</span></span>
  
- <span data-ttu-id="677ec-133">Ein VBA- **String** wird bei einer ByVal-übergabe als Zeiger auf eine Byte-String-BSTR-Struktur Übergeben, bei einer **ByRef**-übergabe als Zeiger auf einen Zeiger.</span><span class="sxs-lookup"><span data-stu-id="677ec-133">A VBA **String** is passed as a pointer to a byte-string BSTR structure when passed ByVal, and as a pointer to a pointer when passed **ByRef**.</span></span>
    
- <span data-ttu-id="677ec-134">Eine VBA- **Variant**, die eine Zeichenfolge enthält, wird bei einer **ByVal**-übergabe als Zeiger auf eine Unicode-Breitzeichen-String-BSTR-Struktur Übergeben, bei einer **ByRef**-übergabe als Zeiger auf einen Zeiger.</span><span class="sxs-lookup"><span data-stu-id="677ec-134">A VBA **Variant** that contains a string is passed as a pointer to a Unicode wide-character string BSTR structure when passed **ByVal**, and as a pointer to a pointer when passed **ByRef**.</span></span>
    
- <span data-ttu-id="677ec-135">Der VBA-Datentyp **Integer** ist eine 16-Bit-Typentsprechung des Datentyps "signed short" in C/C++.</span><span class="sxs-lookup"><span data-stu-id="677ec-135">The VBA **Integer** is a 16-bit type equivalent to a signed short in C/C++.</span></span> 
    
- <span data-ttu-id="677ec-136">Der VBA-Datentyp **Long** ist eine 32-Bit-Typentsprechung für den Datentyp "signed int" in C/C++.</span><span class="sxs-lookup"><span data-stu-id="677ec-136">The VBA **Long** is a 32-bit type equivalent to a signed int in C/C++.</span></span> 
    
- <span data-ttu-id="677ec-137">Sowohl VBA als auch C/C++ unterstützen die Definition benutzerdefinierter Datentypen mit der Anweisung **Type** bzw. **struct**.</span><span class="sxs-lookup"><span data-stu-id="677ec-137">Both VBA and C/C++ allow the definition of user-defined data types, using the **Type** and **struct** statements respectively.</span></span> 
    
- <span data-ttu-id="677ec-138">Der Datentyp **Variant** wird in VBA und C/C++ unterstützt; für C/C++ ist er in den Windows-OLE/COM-Headerdateien als VARIANT definiert.</span><span class="sxs-lookup"><span data-stu-id="677ec-138">Both VBA and C/C++ support the **Variant** data type, defined for C/C++ in the Windows OLE/COM header files as VARIANT.</span></span> 
    
- <span data-ttu-id="677ec-139">VBA-Arrays sind OLE- **SafeArrays**, die für C/C++ in den Windows-OLE/COM-Headerdateien als **SAFEARRAY** sind.</span><span class="sxs-lookup"><span data-stu-id="677ec-139">VBA arrays are OLE **SafeArrays**, defined for C/C++ in the Windows OLE/COM header files as **SAFEARRAY**.</span></span>
    
- <span data-ttu-id="677ec-140">Der VBA-Datentyp **Currency** wird bei einer **ByVal**-übergabe als Struktur des Typs **CY** Übergeben (definiert in der Windows-Headerdatei "wtypes.h") und bei einer **ByRef**-übergabe als Zeiger darauf.</span><span class="sxs-lookup"><span data-stu-id="677ec-140">The VBA **Currency** data type is passed as a structure of type **CY**, defined in the Windows header file wtypes.h, when passed **ByVal**, and as a pointer to this when passed **ByRef**.</span></span>
    
<span data-ttu-id="677ec-141">In VBA werden Datenelemente in benutzerdefinierten Datentypen für 4-Byte-Grenzen gepackt, in Visual Studio werden sie hingegen standardm��ig für 8-Byte-Grenzen gepackt.</span><span class="sxs-lookup"><span data-stu-id="677ec-141">In VBA, data elements in user-defined data types are packed to 4-byte boundaries, whereas in Visual Studio, by default, they are packed to 8-byte boundaries.</span></span> <span data-ttu-id="677ec-142">Daher müssen Sie schließen Sie die Definition des C/C++-Struktur in einer `#pragma pack(4) … #pragma pack()` Block zur Vermeidung von Elemente falsch ausgerichtet wird.</span><span class="sxs-lookup"><span data-stu-id="677ec-142">Therefore you must enclose the C/C++ structure definition in a `#pragma pack(4) … #pragma pack()` block to avoid elements being misaligned.</span></span> 
  
<span data-ttu-id="677ec-143">Nachfolgend finden Sie ein Beispiel für entsprechende Benutzertypdefinitionen.</span><span class="sxs-lookup"><span data-stu-id="677ec-143">The following is an example of equivalent user type definitions.</span></span>
  
```vb
Type VB_User_Type
    i As Integer
    d As Double
    s As String
End Type

```

```cpp
#pragma pack(4)
struct C_user_type
{
    short iVal;
    double dVal;
    BSTR bstr; // VBA String type is a byte string
}
#pragma pack() // restore default

```

<span data-ttu-id="677ec-p109">VBA unterstützt in einigen Fällen einen gr��eren Wertebereich als Excel. Der VBA-Datentyp "double" ist IEEE-konform und unterstützt subnormale Zahlen, die derzeit im Arbeitsblatt auf null abgerundet werden. Der VBA-Datentyp **Date** kann Datumsangaben ab dem 1. Januar 0100 mithilfe negativer serialisierter Datumsangaben darstellen. Excel unterstützt nur serialisierte Datumsangaben gr��er oder gleich null. Der VBA-Datentyp **Currency** ist eine skalierte 64-Bit-Ganzzahl und erreicht Genauigkeiten, die in 8-Byte-Double-Werten nicht unterstützt werden, daher hat er keine Entsprechung im Arbeitsblatt.</span><span class="sxs-lookup"><span data-stu-id="677ec-p109">VBA supports a greater range of values in some cases than Excel supports. The VBA double is IEEE compliant, supporting subnormal numbers that are currently rounded down to zero on the worksheet. The VBA **Date** type can represent dates as early as 1-Jan-0100 using negative serialized dates. Excel only allows serialized dates greater than or equal to zero. The VBA **Currency** type—a scaled 64-bit integer—can achieve accuracy not supported in 8-byte doubles, and so is not matched in the worksheet.</span></span> 
  
<span data-ttu-id="677ec-149">Excel übergibt nur Variant-Werte der folgenden Typen an eine benutzerdefinierte VBA-Funktion.</span><span class="sxs-lookup"><span data-stu-id="677ec-149">Excel only passes Variants of the following types to a VBA user-defined function.</span></span>
  
|<span data-ttu-id="677ec-150">**VBA-Datentyp**</span><span class="sxs-lookup"><span data-stu-id="677ec-150">**VBA data type**</span></span>|<span data-ttu-id="677ec-151">**Bit-Flags für C/C++-Variant-Typ**</span><span class="sxs-lookup"><span data-stu-id="677ec-151">**C/C++ Variant type bit flags**</span></span>|<span data-ttu-id="677ec-152">**Beschreibung**</span><span class="sxs-lookup"><span data-stu-id="677ec-152">**Description**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="677ec-153">Double</span><span class="sxs-lookup"><span data-stu-id="677ec-153">Double</span></span>  <br/> |<span data-ttu-id="677ec-154">**VT_R8**</span><span class="sxs-lookup"><span data-stu-id="677ec-154">**VT_R8**</span></span> <br/> ||
|<span data-ttu-id="677ec-155">Boolean</span><span class="sxs-lookup"><span data-stu-id="677ec-155">Boolean</span></span>  <br/> |<span data-ttu-id="677ec-156">**VT_BOOL**</span><span class="sxs-lookup"><span data-stu-id="677ec-156">**VT_BOOL**</span></span> <br/> ||
|<span data-ttu-id="677ec-157">Date</span><span class="sxs-lookup"><span data-stu-id="677ec-157">Date</span></span>  <br/> |<span data-ttu-id="677ec-158">**VT_DATE**</span><span class="sxs-lookup"><span data-stu-id="677ec-158">**VT_DATE**</span></span> <br/> ||
|<span data-ttu-id="677ec-159">String</span><span class="sxs-lookup"><span data-stu-id="677ec-159">String</span></span>  <br/> |<span data-ttu-id="677ec-160">**VT_BSTR**</span><span class="sxs-lookup"><span data-stu-id="677ec-160">**VT_BSTR**</span></span> <br/> |<span data-ttu-id="677ec-161">OLE-Bstr-Byte-String</span><span class="sxs-lookup"><span data-stu-id="677ec-161">OLE Bstr byte string</span></span>  <br/> |
|<span data-ttu-id="677ec-162">Range</span><span class="sxs-lookup"><span data-stu-id="677ec-162">Range</span></span>  <br/> |<span data-ttu-id="677ec-163">**VT_DISPATCH**</span><span class="sxs-lookup"><span data-stu-id="677ec-163">**VT_DISPATCH**</span></span> <br/> |<span data-ttu-id="677ec-164">Bereichs- und Zellbez�ge</span><span class="sxs-lookup"><span data-stu-id="677ec-164">Range and cell references</span></span>  <br/> |
|<span data-ttu-id="677ec-165">Variant-Wert mit einem Array</span><span class="sxs-lookup"><span data-stu-id="677ec-165">Variant containing an array</span></span>  <br/> |<span data-ttu-id="677ec-166">**VT_ARRAY**</span><span class="sxs-lookup"><span data-stu-id="677ec-166">**VT_ARRAY**</span></span> | <span data-ttu-id="677ec-167">**VT_VARIANT**</span><span class="sxs-lookup"><span data-stu-id="677ec-167">**VT_VARIANT**</span></span> <br/> |<span data-ttu-id="677ec-168">Literale Arrays</span><span class="sxs-lookup"><span data-stu-id="677ec-168">Literal arrays</span></span>  <br/> |
|<span data-ttu-id="677ec-169">Ccy</span><span class="sxs-lookup"><span data-stu-id="677ec-169">Ccy</span></span>  <br/> |<span data-ttu-id="677ec-170">**VT_CY**</span><span class="sxs-lookup"><span data-stu-id="677ec-170">**VT_CY**</span></span> <br/> |<span data-ttu-id="677ec-171">64-Bit-Ganzzahl, skaliert für eine Genauigkeit von 4 Dezimalstellen</span><span class="sxs-lookup"><span data-stu-id="677ec-171">64-bit integer scaled to permit 4 decimal places of accuracy.</span></span>  <br/> |
|<span data-ttu-id="677ec-172">Variant-Wert mit einem Fehler</span><span class="sxs-lookup"><span data-stu-id="677ec-172">Variant containing an error</span></span>  <br/> |<span data-ttu-id="677ec-173">**VT_ERROR**</span><span class="sxs-lookup"><span data-stu-id="677ec-173">**VT_ERROR**</span></span> <br/> ||
||<span data-ttu-id="677ec-174">**VT_EMPTY**</span><span class="sxs-lookup"><span data-stu-id="677ec-174">**VT_EMPTY**</span></span> <br/> |<span data-ttu-id="677ec-175">Leere Zellen oder ausgelassenen Argumente</span><span class="sxs-lookup"><span data-stu-id="677ec-175">Empty cells or omitted arguments</span></span>  <br/> |
   
<span data-ttu-id="677ec-p110">Sie können den Typ eines Übergebenen Variant-Werts in VBA mithilfe von **VarType** überpr�fen, allerdings gibt die Funktion den Typ der Bereichswerte zurück, wenn sie mit Verweisen aufgerufen wird. Um zu ermitteln, ob ein **Variant**-Wert ein **Range**-Verweisobjekt ist, können Sie die **IsObject**-Funktion verwenden.</span><span class="sxs-lookup"><span data-stu-id="677ec-p110">You can check the type of a passed-in Variant in VBA using the **VarType**, except that the function returns the type of the range's values when called with references. To determine if a **Variant** is a **Range** reference object, you can use the **IsObject** function.</span></span> 
  
<span data-ttu-id="677ec-p111">Sie können **Variants** mit Variantenarrays in VBA aus einem **Range** erstellen, indem Sie die zugehörige **Value**-Eigenschaft einem **Variant**-Wert zuweisen. Alle Zellen im Quellbereich, die mit dem Standardwährungsformat aus den zu diesem Zeitpunkt gültigen Landes-/Regionaleinstellungen formatiert sind, werden in Arrayelemente des Typ **Currency** konvertiert. Alle als Datumsangaben formatierten Zellen werden in Arrayelemente des Typs **Date** konvertiert. Zellen mit Zeichenfolgen werden in Breitzeichen- **BSTR**-Variant-Werte konvertiert. Zellen mit Fehlern werden in **Variants** des Typs **VT_ERROR** konvertiert. Zellen mit **Boolean** **True** oder **False** werden in **Variants** des Typs **VT_BOOL** konvertiert.</span><span class="sxs-lookup"><span data-stu-id="677ec-p111">You can create **Variants** that contain arrays of variants in VBA from a **Range** by assigning its **Value** property to a **Variant**. Any cells in the source range that are formatted using the standard currency format for the regional settings in force at the time are converted to array elements of type **Currency**. Any cells formatted as dates are converted to array elements of type **Date**. Cells containing strings are converted to wide-character **BSTR** Variants. Cells containing errors are converted to **Variants** of type **VT_ERROR**. Cells containing **Boolean** **True** or **False** are converted to **Variants** of type **VT_BOOL**.</span></span> 
  
> [!NOTE]
> <span data-ttu-id="677ec-p112">Der **Variant**-Wert speichert **True** als �1 und **False** als 0. Zahlen, die nicht als Datumsangaben oder W�hrungsbetr�ge formatiert sind, werden in Variant-Werte des Typs **VT_R8** konvertiert.</span><span class="sxs-lookup"><span data-stu-id="677ec-p112">The **Variant** stores **True** as -1 and **False** as 0. Numbers not formatted as dates or currency amounts are converted to Variants of type **VT_R8**.</span></span> 
  
### <a name="variant-and-string-arguments"></a><span data-ttu-id="677ec-186">Variant-Wert und Zeichenfolge-Argumente</span><span class="sxs-lookup"><span data-stu-id="677ec-186">Variant and string arguments</span></span>

<span data-ttu-id="677ec-p113">Excel arbeitet intern mit Breitzeichen-Unicode-Strings. Wenn die Deklaration einer benutzerdefinierten VBA-Funktion die Verwendung eines **String**-Arguments angibt, konvertiert Excel die angegebene Zeichenfolge mit einer für das jeweilige Gebietsschema spezifischen Methode in einen Byte-String-Wert. Wenn die Funktion als Unicode-String Übergeben werden soll, muss die benutzerdefinierte VBA-Funktion ein **Variant**- anstelle eines **String**-Arguments verwenden. Die DLL-Funktion kann dann diesen **Variant**-BSTR-Breitzeichen-String von VBA akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="677ec-p113">Excel works internally with wide-character Unicode strings. When a VBA user-defined function is declared as taking a **String** argument, Excel converts the supplied string to a byte-string in a locale-specific way. If you want your function to be passed a Unicode string, your VBA user-defined function should accept a **Variant** instead of a **String** argument. Your DLL function can then accept that **Variant** BSTR wide-character string from VBA.</span></span> 
  
<span data-ttu-id="677ec-p114">Um Unicode-Strings als einer DLL an VBA zurückzugeben, müssen Sie ein **Variant**-String-Argument direkt bearbeiten. Damit dies möglich ist, müssen Sie die DLL-Funktion so deklarieren, dass ein Zeiger auf die **Variant** und im C/C++-Code verwendet wird, und müssen das Argument im VBA-Code als "  `ByRef varg As Variant`" deklarieren. Der alte Zeichenfolgenspeicher muss gelöscht werden, und der neue Zeichenfolgenwert muss unter Verwendung de OLE-Bstr-String-Funktionen nur in der DLL erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="677ec-p114">To return Unicode strings to VBA from a DLL, you should modify a **Variant** string argument in place. For this to work, you must declare the DLL function as taking a pointer to the **Variant** and in your C/C++ code, and declare the argument in the VBA code as  `ByRef varg As Variant`. The old string memory should be released, and the new string value created by using the OLE Bstr string functions only in the DLL.</span></span>
  
<span data-ttu-id="677ec-p115">Um einen Byte-String aus einer DLL an VBA zurückzugeben, müssen Sie ein Byte-String-BSTR-Argument direkt bearbeiten. Damit dies möglich ist, müssen Sie die DLL-Funktion so deklarieren, dass sie einen Zeiger auf einen Zeiger zu BSTR und im C/C++-Code verwendet, und müssen das Argument im VBA-Code als " **ByRef varg As String**" deklarieren.</span><span class="sxs-lookup"><span data-stu-id="677ec-p115">To return a byte string to VBA from a DLL, you should modify a byte-string BSTR argument in place. For this to work, you must declare the DLL function as taking a pointer to a pointer to the BSTR and in your C/C++ code, and declare the argument in the VBA code as ' **ByRef varg As String**'.</span></span>
  
<span data-ttu-id="677ec-p116">Sie sollten nur Zeichenfolgen, die mit diesen Methoden von VBA Übergeben werden, mit den OLE-BSTR-String-Funktionen bearbeiten, um Speicherprobleme zu vermeiden. Sie müssen beispielsweise **SysFreeString** aufrufen, um den Speicher freizugeben, bevor Sie die Übergebene Zeichenfolge überschreiben, und **SysAllocStringByteLen** oder **SysAllocStringLen**, um Speicher für eine neue Zeichenfolge zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="677ec-p116">You should only handle strings that are passed in these ways from VBA using the OLE BSTR string functions to avoid memory-related problems. For example, you must call **SysFreeString** to free the memory before overwriting the passed in string, and **SysAllocStringByteLen** or **SysAllocStringLen** to allocate space for a new string.</span></span> 
  
<span data-ttu-id="677ec-p117">Sie können Excel-Arbeitsblattfehler als **Variants** in VBA erstellen, indem Sie die **CVerr**-Funktion mit den in der folgenden Tabelle aufgeführten Argumenten verwenden. Arbeitsblattfehler können auch mit **Variants** vom Typ **VT_ERROR** und mit den folgenden Werten im **ulVal**-Feld von einer DLL an VBA zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="677ec-p117">You can create Excel worksheet errors as **Variants** in VBA by using the **CVerr** function with arguments as shown in the following table. Worksheet errors can also be returned to VBA from a DLL using **Variants** of type **VT_ERROR**, and with the following values in the **ulVal** field.</span></span> 
  
|<span data-ttu-id="677ec-200">**Fehler**</span><span class="sxs-lookup"><span data-stu-id="677ec-200">**Error**</span></span>|<span data-ttu-id="677ec-201">**UlVal-Wert der Variante**</span><span class="sxs-lookup"><span data-stu-id="677ec-201">**Variant ulVal value**</span></span>|<span data-ttu-id="677ec-202">**CVerr-Argument**</span><span class="sxs-lookup"><span data-stu-id="677ec-202">**CVerr argument**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="677ec-203">#NULL!</span><span class="sxs-lookup"><span data-stu-id="677ec-203">#NULL!</span></span>  <br/> |<span data-ttu-id="677ec-204">2148141008</span><span class="sxs-lookup"><span data-stu-id="677ec-204">2148141008</span></span>  <br/> |<span data-ttu-id="677ec-205">2000</span><span class="sxs-lookup"><span data-stu-id="677ec-205">2000</span></span>  <br/> |
|<span data-ttu-id="677ec-206">#DIV/0!</span><span class="sxs-lookup"><span data-stu-id="677ec-206">#DIV/0!</span></span>  <br/> |<span data-ttu-id="677ec-207">2148141015</span><span class="sxs-lookup"><span data-stu-id="677ec-207">2148141015</span></span>  <br/> |<span data-ttu-id="677ec-208">2007</span><span class="sxs-lookup"><span data-stu-id="677ec-208">2007</span></span>  <br/> |
|<span data-ttu-id="677ec-209">#VALUE!</span><span class="sxs-lookup"><span data-stu-id="677ec-209">#VALUE!</span></span>  <br/> |<span data-ttu-id="677ec-210">2148141023</span><span class="sxs-lookup"><span data-stu-id="677ec-210">2148141023</span></span>  <br/> |<span data-ttu-id="677ec-211">2015</span><span class="sxs-lookup"><span data-stu-id="677ec-211">2015</span></span>  <br/> |
|<span data-ttu-id="677ec-212">#REF!</span><span class="sxs-lookup"><span data-stu-id="677ec-212">#REF!</span></span>  <br/> |<span data-ttu-id="677ec-213">2148141031</span><span class="sxs-lookup"><span data-stu-id="677ec-213">2148141031</span></span>  <br/> |<span data-ttu-id="677ec-214">2023 zurück</span><span class="sxs-lookup"><span data-stu-id="677ec-214">2023</span></span>  <br/> |
|<span data-ttu-id="677ec-215">#NAME?</span><span class="sxs-lookup"><span data-stu-id="677ec-215">#NAME?</span></span>  <br/> |<span data-ttu-id="677ec-216">2148141037</span><span class="sxs-lookup"><span data-stu-id="677ec-216">2148141037</span></span>  <br/> |<span data-ttu-id="677ec-217">2029</span><span class="sxs-lookup"><span data-stu-id="677ec-217">2029</span></span>  <br/> |
|<span data-ttu-id="677ec-218">#NUM!</span><span class="sxs-lookup"><span data-stu-id="677ec-218">#NUM!</span></span>  <br/> |<span data-ttu-id="677ec-219">2148141044</span><span class="sxs-lookup"><span data-stu-id="677ec-219">2148141044</span></span>  <br/> |<span data-ttu-id="677ec-220">2036</span><span class="sxs-lookup"><span data-stu-id="677ec-220">2036</span></span>  <br/> |
|<span data-ttu-id="677ec-221">#N/A</span><span class="sxs-lookup"><span data-stu-id="677ec-221">#N/A</span></span>  <br/> |<span data-ttu-id="677ec-222">2148141050</span><span class="sxs-lookup"><span data-stu-id="677ec-222">2148141050</span></span>  <br/> |<span data-ttu-id="677ec-223">2042</span><span class="sxs-lookup"><span data-stu-id="677ec-223">2042</span></span>  <br/> |
   
<span data-ttu-id="677ec-224">Beachten Sie, dass der **ulVal**-Wert der Variante dem **CVerr**-Argumentwert plus der Hexadezimalzahl x800A0000 entspricht.</span><span class="sxs-lookup"><span data-stu-id="677ec-224">Note that the Variant **ulVal** value given is equivalent to the **CVerr** argument value plus x800A0000 hexadecimal.</span></span> 
  
## <a name="calling-dll-functions-directly-from-the-worksheet"></a><span data-ttu-id="677ec-225">Aufrufen von DLL-Funktionen direkt aus dem Arbeitsblatt</span><span class="sxs-lookup"><span data-stu-id="677ec-225">Calling DLL functions directly from the worksheet</span></span>

<span data-ttu-id="677ec-p118">Sie können aus dem Arbeitsblatt nicht auf Win32-DLL-Funktionen zugreifen, ohne beispielsweise VBA oder XLM als Schnittstelle zu verwenden oder ohne Excel vorab Angaben zur Funktion, zu deren Argumenten und zum Rückgabetyp zu machen. Der erforderliche Prozess wird als Registrierung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="677ec-p118">You cannot access Win32 DLL functions from the worksheet without, for example, using VBA or XLM as interfaces, or without letting Excel know about the function, its arguments, and its return type in advance. The process of doing this is called registration.</span></span>
  
<span data-ttu-id="677ec-228">Der Zugriff auf die Funktionen einer DLL kann in einem Arbeitsblatt mit den folgenden Methoden erfolgen:</span><span class="sxs-lookup"><span data-stu-id="677ec-228">The ways in which the functions of a DLL can be accessed in the worksheet are as follows:</span></span>
  
- <span data-ttu-id="677ec-229">Deklarieren der Funktion in VBA wie zuvor beschrieben und Zugreifen auf die Funktion über eine benutzerdefinierte VBA-Funktion</span><span class="sxs-lookup"><span data-stu-id="677ec-229">Declare the function in VBA as described previously and access it via a VBA user-defined function.</span></span>
    
- <span data-ttu-id="677ec-230">Aufrufen der DLL-Funktion durch Ausführen von CALL für eine XLM-Makrovorlage und Zugreifen auf die Funktion über eine benutzerdefinierte XLM-Funktion</span><span class="sxs-lookup"><span data-stu-id="677ec-230">Call the DLL function using CALL on an XLM macro sheet, and access it via an XLM user-defined function.</span></span>
    
- <span data-ttu-id="677ec-231">Verwenden eines XLM- oder VBA-Befehls zum Aufrufen der XLM-Funktion **REGISTER**, die die Informationen bereitstellt, die Excel zum Erkennen der Funktion benötigt, wenn diese in eine Arbeitsblattzelle eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="677ec-231">Use an XLM or VBA command to call the XLM **REGISTER** function, which provides the information that Excel needs to recognize the function when it is entered into a worksheet cell.</span></span> 
    
- <span data-ttu-id="677ec-232">Umwandeln der DLL in eine XLL und Registrieren der Funktion mithilfe der C-API-Funktion **xlfRegister** beim Aktivieren der XLL</span><span class="sxs-lookup"><span data-stu-id="677ec-232">Turn the DLL into an XLL and register the function using the C API **xlfRegister** function when the XLL is activated.</span></span> 
    
<span data-ttu-id="677ec-p119">Die vierte Methode ist eigenst�ndig: Der Code, der die Funktionen registriert, und der Funktionscode sind beide im gleichen Codeprojekt enthalten. Am Add-In vorgenommene �nderungen erfordern keine �nderungen an einem XLM-Blatt oder einem VBA-Codemodul. Um dies auf gut verwaltete Weise durchzuführen, ohne den Funktionsumfang der C-API zu verlassen, müssen Sie die DLL in eine XLL umwandeln und das resultierende Add-In mithilfe des Add-In-Managers laden. Dies ermöglicht es Excel, eine Funktion aufzurufen, die die DLL verfügbar macht, wenn das Add-In geladen oder aktiviert wird; von dort aus können Sie alle Funktionen der XLL registrieren und andere DLL-Initialisierungen ausführen.</span><span class="sxs-lookup"><span data-stu-id="677ec-p119">The fourth approach is self-contained: the code that registers the functions and the function code are both contained in the same code project. Making changes to the add-in does not involve making changes to an XLM sheet or to a VBA code module. To do this in a well-managed way while still staying within the capabilities of the C API, you must turn your DLL into an XLL and load the resulting add-in by using the Add-in Manager. This enables Excel to call a function that your DLL exposes when the add-in is loaded or activated, from which you can register all of the functions your XLL contains, and carry out any other DLL initialization.</span></span>
  
## <a name="calling-dll-commands-directly-from-excel"></a><span data-ttu-id="677ec-237">Aufrufen von DLL-Befehle direkt in Excel</span><span class="sxs-lookup"><span data-stu-id="677ec-237">Calling DLL commands directly from Excel</span></span>

<span data-ttu-id="677ec-238">Auf Win32-DLL-Befehle kann nicht direkt aus Excel-Dialogfeldern und -Menüs zugegriffen werden, ohne dass eine Schnittstelle wie z.�B. VBA vorhanden ist oder die Befehle vorab registriert werden.</span><span class="sxs-lookup"><span data-stu-id="677ec-238">Win32 DLL commands are not accessible directly from Excel dialog boxes and menus without there being an interface, such as VBA, or without the commands being registered in advance.</span></span>
  
<span data-ttu-id="677ec-239">Auf die Befehle einer DLL kann mit folgenden Methoden zugegriffen werden:</span><span class="sxs-lookup"><span data-stu-id="677ec-239">The ways in which you can access the commands of a DLL are as follows:</span></span>
  
- <span data-ttu-id="677ec-240">Deklarieren des Befehls in VBA wie zuvor beschrieben und Zugreifen auf die Funktion über ein VBA-Makro</span><span class="sxs-lookup"><span data-stu-id="677ec-240">Declare the command in VBA as described previously and access it via a VBA macro.</span></span>
    
- <span data-ttu-id="677ec-241">Aufrufen des DLL-Befehls durch Ausführen von **CALL** für eine XLM-Makrovorlage und Zugreifen auf die Funktion über ein XLM-Makro</span><span class="sxs-lookup"><span data-stu-id="677ec-241">Call the DLL command using **CALL** on an XLM macro sheet, and access it via an XLM macro.</span></span> 
    
- <span data-ttu-id="677ec-242">Verwenden eines XLM- oder VBA-Befehls zum Aufrufen der XLM-Funktion **REGISTER**, die die Informationen bereitstellt, die Excel zum Erkennen des Befehls benötigt, wenn dieser in ein Dialogfeld eingegeben wird, das den Namen eines Makrobefehls erwartet</span><span class="sxs-lookup"><span data-stu-id="677ec-242">Use an XLM or VBA command to call the XLM **REGISTER** function, which provides the information Excel needs to recognize the command when it is entered into a dialog box that expects the name of a macro command.</span></span> 
    
- <span data-ttu-id="677ec-243">Umwandeln der DLL in eine XLL und Registrieren des Befehls mit der C-API-Funktion **xlfRegister**</span><span class="sxs-lookup"><span data-stu-id="677ec-243">Turn the DLL into an XLL and register the command using the C API **xlfRegister** function.</span></span> 
    
<span data-ttu-id="677ec-p120">Wie bereits weiter oben im Kontext von DLL-Funktionen erl�utert, ist die vierte Methode die eigenst�ndigste, und Registrierungscode und Befehlscode bleiben hier nahe beieinander. Hierzu müssen Sie die DLL in eine XLL umwandeln und das resultierende Add-In mithilfe des Add-In-Managers laden. Wenn Sie Befehle auf diese Weise registrieren, haben Sie außerdem die Möglichkeit, den Befehl an ein Element der Benutzeroberfläche anzuf�gen, z. B. ein benutzerdefiniertes Men�, oder ein Ereignistrap einzurichten, das den Befehl bei einem bestimmten Tastaturanschlag oder einem anderen Ereignis aufruft.</span><span class="sxs-lookup"><span data-stu-id="677ec-p120">As discussed earlier in the context of DLL functions, the fourth approach is the most self-contained, keeping the registration code close to the command code. To do this, you must turn your DLL into an XLL and load the resulting add-in using the Add-in Manager. Registering commands in this way also lets you attach the command to an element of the user interface, such as a custom menu, or to set up an event trap that calls the command on a given keystroke or other event.</span></span>
  
<span data-ttu-id="677ec-247">Für alle bei Excel registrierten XLL-Befehle wird von Excel die folgende Form vorausgesetzt.</span><span class="sxs-lookup"><span data-stu-id="677ec-247">All XLL commands that are registered with Excel are assumed by Excel to be of the following form.</span></span>
  
```cpp
int WINAPI my_xll_cmd(void)
{
// Function code...
    return 1;
}
```

> [!NOTE]
> <span data-ttu-id="677ec-p121">Der Rückgabewert wird von Excel ignoriert, es sei denn, der Aufruf erfolgt aus einer XLM-Makrovorlage; in diesem Fall wird der Rückgabewert in **TRUE** oder **FALSE** konvertiert. Sie müssen daher 1 zurückgeben, wenn der Befehl erfolgreich ausgeführt wurde, und 0 bei einem Fehler oder Benutzerabbruch.</span><span class="sxs-lookup"><span data-stu-id="677ec-p121">Excel ignores the return value unless it is called from an XLM macro sheet, in which case the return value is converted to **TRUE** or **FALSE**. You should therefore return 1 if your command executed successfully, and 0 if it failed or was canceled by the user.</span></span> 
  
## <a name="dll-memory-and-multiple-dll-instances"></a><span data-ttu-id="677ec-250">DLL-Arbeitsspeicher und mehrere DLL-Instanzen</span><span class="sxs-lookup"><span data-stu-id="677ec-250">DLL memory and multiple DLL instances</span></span>

<span data-ttu-id="677ec-p122">Wenn eine Anwendung eine DLL lädt, wird der ausführbare Code der DLL in den globalen Heap geladen, damit er ausgeführt werden kann, und für die Datenstrukturen wird Speicherplatz im globalen Heap zugewiesen. Windows verwendet Speicherzuordnung, damit diese Speicherbereiche so angezeigt werden, als w�ren sie im Prozess der Anwendung enthalten, sodass die Anwendung darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="677ec-p122">When an application loads a DLL, the DLL's executable code is loaded into the global heap so that it can be run, and space is allocated on the global heap for its data structures. Windows uses memory mapping to make these areas of memory appear as if they are in the application's process so that the application can access them.</span></span>
  
<span data-ttu-id="677ec-p123">Wenn anschließend eine zweite Anwendung die DLL lädt, erstellt Windows keine weitere Kopie des ausführbaren DLL-Codes, da der Speicher schreibgeschützt ist. Windows ordnet den Speicher des ausführbaren DLL-Codes den Prozessen beider Anwendungen zu. Es wird jedoch auch eine zweiter Speicherbereich für eine private Kopie der DLL-Datenstrukturen zugewiesen, und diese Kopie wird nur dem zweiten Prozess zugeordnet. Dadurch wird sichergestellt, dass keine Anwendung einen Konflikt mit den DLL-Daten der anderen Anwendung verursachen kann.</span><span class="sxs-lookup"><span data-stu-id="677ec-p123">If a second application then loads the DLL, Windows does not make another copy of the DLL executable code, as that memory is read-only. Windows maps the DLL executable code memory to the processes of both applications. It does, however, allocate a second space for a private copy of the DLL's data structures and maps this copy to the second process only. This ensures that neither application can interfere with the DLL data of the other.</span></span>
  
<span data-ttu-id="677ec-p124">Dies bedeutet, dass sich DLL-Entwickler keine Gedanken darüber machen müssen, dass mehrere Anwendungen oder mehrere Instanzen der gleichen Anwendung auf statische und globale Variablen und Datenstrukturen zugreifen. Jede Instanz jeder Anwendung ruft eine eigene Kopie der DLL-Daten ab.</span><span class="sxs-lookup"><span data-stu-id="677ec-p124">This means that DLL developers do not have to be concerned about static and global variables and data structures being accessed by more than one application, or more than one instance of the same application. Every instance of every application gets its own copy of the DLL's data.</span></span>
  
<span data-ttu-id="677ec-p125">DLL-Entwickler müssen sich jedoch Gedanken darüber machen, dass dieselbe Instanz einer Anwendung die DLL mehrmals aus unterschiedlichen Threads aufruft, da dies zu einem Konflikt für die Daten dieser Instanz führen kann. Weitere Informationen finden Sie unter [Speicherverwaltung in Excel](memory-management-in-excel.md).</span><span class="sxs-lookup"><span data-stu-id="677ec-p125">DLL developers do need to be concerned about the same instance of an application calling their DLL many times from different threads, because this can result in contention for that instance's data. For more information, see [Memory Management in Excel](memory-management-in-excel.md).</span></span>
  
## <a name="see-also"></a><span data-ttu-id="677ec-261">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="677ec-261">See also</span></span>

- [<span data-ttu-id="677ec-262">Entwickeln von DLLs</span><span class="sxs-lookup"><span data-stu-id="677ec-262">Developing DLLs</span></span>](developing-dlls.md) 
- [<span data-ttu-id="677ec-263">Aufrufen von Excel von der DLL oder XLL aus</span><span class="sxs-lookup"><span data-stu-id="677ec-263">Calling into Excel from the DLL or XLL</span></span>](calling-into-excel-from-the-dll-or-xll.md)

